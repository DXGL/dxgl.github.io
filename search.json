[{"title":"UGUI屏幕适配思考","url":"/2018/04/18/compaire-screen/","content":"最近一众“全面屏”手机的出现，让之前的项目遇到很多适配问题，由此考虑如何简便而快捷的适配更多新设备的屏幕尺寸。</br>\n\n## 问题分析\n\n选取iphoneX,iphone 6S,ipad分辨率为例，大体上，会遇到如下问题：\n1. 以stretch模式定义控件大小，在不同分辨率下，控件会因为屏幕大小的改变而改变比例。\n2. 以长宽+位置定义控件大小，在不同分辨率下，控件常常相互重叠或者超出屏幕。\n\n![1_2](/image/1_2.png)\n3. 以Anchors+stretch定义控件大小，控件比例正确，但往往长宽改变造成显示内容改变。\n\n![3](/image/3.png)\n\n## 解题思路\n\n分析上述问题，实际上，所有UI的适配问题，最终可以归结为两类：\n1. 每个组件长宽和位置均保持设计原稿大小，屏幕变化后，无法完整显示所有组件。\n2. 每个组件长宽和位置均使用屏幕比例表示，屏幕变化后，可以完整显示所有组件，但组件大小和内容比例全部失真。\n\n根据以上问题，合理的屏幕适配效果应该是，每个组件能够完全显示在新的分辨率下，且位置布局保持原本比例，允许一定的长宽位置变化。</br>\n做到这点，首先我们需要能够快速更改整个UI布局，因而第一步，需要能够将原始UI转化为数据，然后用数据，在新的分辨率下重新生成UI布局。一般的，每一个UI组件，都包含一个RectTransform控件，因而使用以下代码，可以方便的将一个UI的Anchors布局数据化。这里数据以XML的形式保存方便阅读。\n<pre><code>\n    private void Bake(RectTransform node)\n    {\n        if (node.childCount < 1)\n            throw new System.Exception(\"No GUI in this node of hierarchy.\");\n\n        var doc = new XmlDocument();\n        var declaration = doc.CreateXmlDeclaration(\"1.0\", \"UTF-8\", null);\n        doc.AppendChild(declaration);\n\n        var root = doc.CreateElement(\"Root\");\n        Bake(doc, root, node);\n        doc.AppendChild(root);\n\n        var path = System.IO.Path.Combine(Application.streamingAssetsPath, \"gui\");\n        path = System.IO.Path.Combine(path, \"main.xml\");\n        doc.Save(path);\n        AssetDatabase.Refresh();\n    }\n\n    private void Bake(XmlDocument doc, XmlElement elem, RectTransform node)\n    {\n        for (var i = 0; i < node.childCount; ++i)\n        {\n            // 把递归移动到堆上免得炸了\n            var action = new System.Action&ltXmlDocument, XmlElement, RectTransform&gt(Bake);\n            var e = doc.CreateElement(\"Node\");\n            elem.AppendChild(e);\n            action(doc, e, node.GetChild(i).GetComponent&ltRectTransform&gt());\n        }\n        var x = doc.CreateAttribute(\"x\");\n        x.Value = node.anchoredPosition.x.ToString();\n        elem.Attributes.Append(x);\n        var y = doc.CreateAttribute(\"y\");\n        y.Value = node.anchoredPosition.y.ToString();\n        elem.Attributes.Append(y);\n        var w = doc.CreateAttribute(\"width\");\n        w.Value = node.rect.width.ToString();\n        elem.Attributes.Append(w);\n        var h = doc.CreateAttribute(\"height\");\n        h.Value = node.rect.height.ToString();\n        elem.Attributes.Append(h);\n        var min = doc.CreateAttribute(\"anchor-min\");\n        min.Value = node.anchorMin.ToString();\n        elem.Attributes.Append(min);\n        var max = doc.CreateAttribute(\"anchor-max\");\n        max.Value = node.anchorMax.ToString();\n        elem.Attributes.Append(max);\n    }\n</code></pre>\n\n保存的数据结果类似这样。\n![4](/image/4.png)\n\n这里我只保存了变换和位置数据。然后使用以下代码，可以简单的对拥有相同分支结构和节点数量的UIGI进行位置重排。\n<pre><code>\n    private void Reset(RectTransform rootNode)\n    {\n        XmlDocument doc = new XmlDocument();\n        doc.LoadXml(data.text);\n\n        var root = doc[\"Root\"];\n        Reset(rootNode, root);\n    }\n\n    private void Reset(RectTransform node, XmlNode data)\n    {\n        for (int i = 0; i < data.ChildNodes.Count; ++i)\n        {\n            var ndata = data.ChildNodes[i];\n            var n = node.GetChild(i) as RectTransform;\n            SetNodeData(n, ndata);\n            var action = new System.Action'<'RectTransform, XmlNode'>'(Reset);\n            action(n, ndata);\n        }\n    }\n\n    private RectTransform GenNode(RectTransform parent, XmlNode data)\n    {\n        var node = new GameObject(\"Node\", typeof(RectTransform));\n        var t = node.GetComponent&ltRectTransform&gt();\n        t.SetParent(parent);\n        SetNodeData(t, data);\n        return t;\n    }\n\n    private void SetNodeData(RectTransform node, XmlNode data)\n    {\n        var x = float.Parse(data.Attributes[\"x\"].Value);\n        var y = float.Parse(data.Attributes[\"y\"].Value);\n        var w = float.Parse(data.Attributes[\"width\"].Value);\n        var h = float.Parse(data.Attributes[\"height\"].Value);\n        var min = StringToVector2(data.Attributes[\"anchor-min\"].Value);\n        var max = StringToVector2(data.Attributes[\"anchor-max\"].Value);\n\n        node.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, w);\n        node.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, h);\n        node.anchoredPosition = new Vector2(x, y);\n        node.anchorMin = min;\n        node.anchorMax = max;\n    }      \n\n    private Vector2 StringToVector2(string str)\n    {\n        var strs = str.Replace(\"(\", \"\").Replace(\")\", \"\").Split(',');\n        return new Vector2(\n            float.Parse(strs[0]),\n            float.Parse(strs[1]));\n    }\n</code></pre>\n\n当GUI布局能够数据化后，回顾问题分析中关于各种问题的描述，从直观数学上看，anchors+stretch布局从数值上最正确。然而当屏幕改变后，由于长宽比也发生改变，往往按照比例布局，最终得到的结果很容易造成图像的比例失衡，类似于原本的正方形变成了长方形的问题就变得很普遍。</br>\n为了解决这个问题，需要为控件大小引入一个最佳比例的概念。比如100:100的控件，在任何分辨率下，只有1:1的比例，可以得最佳视觉效果，因而按照一边计算在新UI中的长度或宽度，再用比例得到另外一边，就可以使UI控件在更多分辨率下呈现良好效果。</br>\n这里需要注意的是，Unity中，总是以Screen.Height来计算RectTrasnform，因而这里用到的计算方式，也采取这一办法，先按两个显示器比例计算控件高度，再用高度以最佳比例得到宽度，然后再用保存的anchor点对控件位置进行重排。</br>\n\n稍微改动UI重排列的代码，可以使用一套数据，快速适应更多分辨率，具体如下：\n\n<pre><code>\n    private void SetNodeData(RectTransform node, XmlNode data)\n    {\n        // 读取原始数据\n        var x = float.Parse(data.Attributes[\"x\"].Value);\n        var y = float.Parse(data.Attributes[\"y\"].Value);\n        var w = float.Parse(data.Attributes[\"width\"].Value);\n        var h = float.Parse(data.Attributes[\"height\"].Value);\n        var anchor_min = StringToVector2(data.Attributes[\"anchor-min\"].Value);\n        var anchor_max = StringToVector2(data.Attributes[\"anchor-min\"].Value);\n\n        // stretch模式，按比例适配控件\n        var X = x / rootSize.x * Width;\n        var Y = y / rootSize.y * Height;\n        var W = w / rootSize.x * Width;\n        var H = h / rootSize.y * Height;\n        var origin = new Rect(X, Y, W, H);\n\n        // 先恢复anchors\n        node.anchorMin = anchor_min;\n        node.anchorMax = anchor_max;\n        node.ForceUpdateRectTransforms();\n\n        // 把UI约束在屏幕内\n        W = w / h * H;\n        var current = new Rect(X, Y, W, H);\n\n        var align = PickSortingPoint(node);\n        var pos = CalculateAnchorPos(align, origin, current);\n\n        node.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, W);\n        node.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, H);\n        node.anchoredPosition = pos;\n    }\n    \n    private Vector2 CalculateAnchorPos(UGUIGenAlignment align, Rect o, Rect c)\n    {\n        var result = new Vector2(c.x, c.y);\n\n        switch (align)\n        {\n            case UGUIGenAlignment.RightTop:\n            {\n                result.x += (o.width - c.width) * 0.5f;\n                result.y += (o.height - c.height) * 0.5f;\n                break;\n            }\n            case UGUIGenAlignment.RightMid:\n            {\n                result.x += (o.width - c.width) * 0.5f;\n                if (result.y > 0)\n                    result.y -= (o.height - c.height) * 0.5f;\n                if (result.y < 0)\n                    result.y += (o.height - c.height) * 0.5f;\n                break;\n            }\n            case UGUIGenAlignment.RightBottom:\n            {\n                result.x += (o.width - c.width) * 0.5f;\n                result.y -= (o.height - c.height) * 0.5f;\n                break;\n            }\n            case UGUIGenAlignment.MidTop:\n            {\n                if (result.x < 0)\n                    result.x += (o.width - c.width) * 0.5f;\n                if (result.x > 0)\n                    result.x -= (o.width - c.width) * 0.5f;\n                result.y += (o.height - c.height) * 0.5f;\n                break;\n            }\n            case UGUIGenAlignment.Center:\n            {\n                if (result.x < 0)\n                    result.x += (o.width - c.width) * 0.5f;\n                if (result.x > 0)\n                    result.x -= (o.width - c.width) * 0.5f;\n                if (result.y > 0)\n                    result.y -= (o.height - c.height) * 0.5f;\n                if (result.y < 0)\n                    result.y += (o.height - c.height) * 0.5f;\n                break;\n            }\n            case UGUIGenAlignment.MidBottom:\n            {\n                if (result.x < 0)\n                    result.x += (o.width - c.width) * 0.5f;\n                if (result.x > 0)\n                    result.x -= (o.width - c.width) * 0.5f;\n                result.y -= (o.height - c.height) * 0.5f;\n                break;\n            }\n            case UGUIGenAlignment.LeftTop:\n            {\n                result.x -= (o.width - c.width) * 0.5f;\n                result.y += (o.height - c.height) * 0.5f;\n                break;\n            }\n            case UGUIGenAlignment.LeftMid:\n            {\n                result.x -= (o.width - c.width) * 0.5f;\n                if (result.y > 0)\n                    result.y -= (o.height - c.height) * 0.5f;\n                if (result.y < 0)\n                    result.y += (o.height - c.height) * 0.5f;\n                break;\n            }\n            case UGUIGenAlignment.LeftBottom:\n            {\n                result.x -= (o.width - c.width) * 0.5f;\n                result.y -= (o.height - c.height) * 0.5f;\n                break;\n            }\n        }\n        return result;\n    }\n\n</code></pre>\n\n重排的效果大体如下图：\n![5](/image/5.png)\n\n完整的项目链接可以点击[这里](https://github.com/zardlee1937/UGUIResorting)查看下载。","tags":["Unity3D"]},{"title":"Unity3D总结-AssetBundle","url":"/2018/04/12/unity3d-summary/","content":"\n## 打包\n\n#### 接口\n\n1. 在Unity3D 2017中，Assetstore提供了官方的AssetBundle可视化工具 -- AssetBundle Browser。可以使用图形化界面方便的打包AssetBundle。\n2. 通过BuildPipline.BuildAssetBundle()函数打包，例如\n\n<pre>\n    <code>\n    // 以下代码在Unity3d File菜单下添加一个build按钮来打包bundle\n    </code>\n</pre>\n\n#### 策略\n\n1. 打包AssetBundle需要根据项目的需求选择策略。一般的，大的资源分配策略有下：\n    * 根据资源所属场景分配\n    * 根据资源业务相关性分配\n2. 场景不仅仅是指Unity3D的Level，是指资源出现的场景。比如一幅地图上用到的所有模型，纹理，声音。再比如一个UI页面上用到的图集，Sprite。\n3. 业务相关性，则是根据所属对象和对象出现以及使用的情况分。比如进入一间房子需要显示桌子椅子和其他室内部件，这些部件所关联的Prefab，纹理，材质等等。\n\n---\n\n## 加载\n\n1. 加载的核心接口一共三个\n    * WWW = new WWW(Path) / UnityWebRequest.GetAssetBundle (两种方式实际都是network streaming形式，这里统称Web方式)\n    * AssetBundle.LoadFromFile(Path)\n    * AssetBundle.LoadFromMemoery(BinaryData)\n2. Netwrok可以使用coutoutine形式，从一个文件路径加载bundle。加载过程异步，并且会创建多个WebStream，适合同时加载多个小块资源。需要注意，使用完成后通过释放Request或WWW来释放WebStream。当加载AssetBundle时，Web方式与NetworkAssetBundle.LoadFromFile速度相差无几，100次平均下来差距在2-8ms左右。例如：\n\n<pre><code>\n    // 以下代码加载速度与AssetBundle.LoadFromFile相近\n    private IEnumerator WWWLoader()\n    {\n        var loader = new WWW(Path.Combine(path, n));\n        yield return loader;\n        loader.Dispose();\n        loader = null;\n    }\n    // 基本等同于\n    private IEnumerator WebRequest()\n    {\n        var request = UnityWebRequest.GetAssetBundle(Path.Combine(path, n));\n        yield return request.SendWebRequest();\n        var bundle = DownloadHandlerAssetBundle.GetContent(request);\n        request = null;\n    }\n</code></pre>\n\n","tags":["Unity3D"]},{"title":"Directx12 接口总结-概念篇","url":"/2018/03/28/direct3d-12-interface/","content":"\n## Design Philosophy\n\ndx12由于开放了更底层的硬件接口，使开发者可以完全控制计算任务什么时候提交到gpu，因而在使用上比起之前的接口有两改进：\n1. 没有单一的immidiate context，因此可以使用多线程handle多个context。\n2. 设置好的一次渲染过程可以重复使用。\ndx12的设计，使cpu/gpu之间更像client/server之间的关系。cpu在本地分配堆存储数据，通过api允许的接口申请gpu管辖的内存，通过公用数据结构的形式上传cpu保持的数据和代码到gpu，再由gpu计算渲染结果返回公用内存，最后通过一套输出接口（dxgi）输出到显示器。同时cpu也可以访问计算后的结果。\ndx12的内存模型，也更加接近于由开发者申请提交，cpu填充，开发者调度使用，一改以往完全由后台调度的策略。开发者需要为正确的使用和调用内存对象做更多工作，同时也能因此获得更高的app执行效率。这之间的关系就好比是c# gc和cpp alloc。\n\n## Components\n\n### Command Queue and Command List\n\n为了实现能够多线程提交和复用渲染，需要从结构上更改d3d app的gpu渲染工作流。dx12针对之前的结构，做出了三个重大改进：\n1. 去除immediate context。使用command list代替原本的immediate context。每个command list包含原本api中的图源和渲染状态，可以在单独线程中存在。\n2. app现在可以控制gpu如何组织调用渲染过程。使得相同的渲染过程可以重复调用。\n3. app现在允许控制什么时候如何提交渲染过程。\n\n#### Command list\n\ncommand list允许app保存一个绘制或者状态改变的调用过程，并在晚些时候通过gpu来执行这个过程。\n* 为了充分利用现代硬件的功能，dx12加入了second level of command list。被称作bundles。\n* first level command list(direct command list)可以被直接引用，bundles则允许app在direct command list中打包一些小型api commands。\n* bundles在创建时会被尽可能的预处理以提高之后的执行效率。\n* bundles可以被包含在多个direct command list中，并被同个的command list多次执行。\n* 使用bundles可以提高cpu单线程效率。由于bundles是被预处理并可以多次提交的，它对其中捆绑的操作有一定要求。\n* 如果一个command list已经确认执行完毕。在提交新的执行请求前，它可以被重复多次执行。\n* 在gpu上执行工作，app需要有效的通过command queue提交command list。\n* 一个direct command list可以被直接提交并多次执行，但是在下次提交执行之前，app不知道前次的command list是否执行完毕。\n* bundles没有并发限制可以被执行多次。但bundles不能通过command queue直接提交。\n* 任何线程都可以在任何时间向任意的command queue提交command list，运行时会按照预先排列好的提交顺序，自动序列化command queue中的command list。\n\n#### Command Queue\n\ncommand queue用来提交并执行command list。这种架构方式允许开发者更高效的使用cpu和gpu。\n* command queue的使用可以让开发者避免由于意外的同步造成的效率损失。\n* command queue的使用可以让开发者在更高级别的同步发生时，使用更加高效（多个线程同时提交）精确（使用下标专门提交某个command list）的方式。这意味着运行时和图形驱动将在工程化的并发中花费更少的时间。\n* command queue的使用可以使大消耗的操作更有效率。\n\ncommand queue的结构使接口达成了这些改进:\n1. 增加并发：app可以在进行前台工作（如渲染）时，同时进行更深层次的后台工作（如解码视频编码）。\n2. 同步执行低优先级的gpu工作：command queue结构允许gpu在一个非同步线程中无锁的执行低优先级gpu工作和原子操作。\n3. 高优先级工作：command queue的设计允许脚本打断3d渲染工作，去做少量高优先级计算，以便cpu能够尽早获得结果。\n4. 每个command queue只能够保存并提交一个类型的command list。\n\n### Descriptor Heaps (DH)\n\ncpu修改创建，用来保存和提交descriptor。\n* 可以创建完整的heap来保存提交新的descriptor。也可以重新分配空间来修改原有的提交顺序。\n* 在被command list引用之前，可以直接由cpu编辑修改。但当引用DH的command list被提交后，该DH则不能被修改。\n* dx12必须通过DH来访问descriptor。\n* DH可以通过以下策略进行管理：\n    1. 为下次draw call填充一个fresh area。在每次command list访问时，移动DT pointer到fresh开头。优点：可以避免记录特定DT pointer的位置。缺点：DH上很可能有许多重复的descriptor，当渲染相同或近似场景时，DH的内存将很快被用完。对于那些在cpu上记录，在gpu上渲染的DH，这种策略需要避免产生访问冲突。(动态填充策略)\n    2. 预先根据descriptor的需要创建DH作为一个场景的一部分，之后在绘制时仅仅设置DT即可。\n    3. 将DH当作一个包含所有需要的descriptor和其所在位置的大数组。draw call通过index去访问固定区段的heap内容。（预先填充策略）\n* 确保root constants and root descriptors通过read/write来访问，而非完整的重新创建，可以在大多数硬件上进一步提升DH性能。\n\n#### Descriptor\n\n用gpu非公开的数据格式描述一个gpu对象的小区块。包含以下四类（PS：其中1，2，3可以在同个heap中存在，4则需要单独heap保存。）：\n* Shader Resource Views (SRVs)\n* Unordered Access Views (UAVs)\n* Constant Buffer Views (CBVs)\n* Samplers\n硬件驱动不会保有descriptor。驱动仅仅绑定render target以保证swap chain工作正常。由于硬件不会保有descriptor对象，每个对象需要保有驱动所需要的资源地址以便硬件访问。\n\n#### Descriptor Table（DT）\n\n用来引用DH上一段descriptor的结构。使硬件可以使用更加快捷轻量的方式访问drescriptor。DT以在图形管线生成一个root signature并使用索引的方式来引用DT保有的资源。\n\n### Graphic Pipeline State\n\n#### The Direct3d 12 Pipelines\n\n在说明d3d12 pipeline之前，首先描述一下dx11的render pipeline。本质上，dx12的pipeline是针对该版本的扩展。</br>\n\nd3d11 pipeline大体分为以下阶段：\n1. Input Assmebler\n    * 使用primitive type组织primitive data，提供其他阶段使用。\n    * 链接系统默认值以便帮助shader更加有效的执行。\n2. Vertex Shader\n    * 处理从IA阶段传入的顶点数据。\n    * 每个顶点产生一次数据，计算并产生一次输出传给下个阶段。（理论上有毒少个顶点就会有多少次Vertex Shader调用\n    * VS一次最大允许16个32位浮点数的传入和传出。\n    * VS必须存在并且必须传出一个值。\n3. Tessellation\n    * 实际用来细分区面，在早期管线中，这部分由cpu实现。现在将它移动到gpu。\n    * Tessellation做的事，是顶点和面数较小的图元上，通过计算增加顶点和面数，并传给下个阶段。\n    * Tessellation阶段的意义在于，可以减少数据的输入和上载数量，但必然的会消耗gpu运算效率。\n    * Tessellation阶段一般由硬件实现，它有两个相关的可编程阶段\n        1. Hull shader\n            * 每个三角面片调用一次。把输入的低面数的控制点，扩展成更高的面数的控制点。比如3个控制点的三角形扩展成9个控制点的三个三角形。从而构成更多的表面细节。\n            * 单次最多输入1-32个控制点。最多输出1-32个控制点，输出的控制点数跟镶嵌参数(tessellation factors)无关。从Hull输出的控制点和面片常量(path constant data)可以被Domain消耗。输出的Tessellation Factors挥别Tesselator使用。\n            * Tessellation factors决定面片被细分的程度。\n        2. Domain shader\n            * Tesselator每输出一个纹理坐标运行一次。\n            * 使用Hull输出的图元控制点。\n            * 输出顶点位置。\n4. Geometry Shader\n5. Rasterizer\n6. Pixel Shader\n7. Output Merge","tags":["D3D"]}]